# 카카오톡 실시간 메시지 송수신 통합 에이전트 (v1.0)

본 프로젝트는 윈도우 OS 환경에서 카카오톡 PC 버전의 데이터를 실시간으로 수집(DB화)하고, 사용자 방해 없이 메시지를 전송하는 통합 관제 프로그램입니다. 단순 매크로를 넘어 **데이터 무결성** 과 **사용자 경험(UX)** 을 중점으로 설계해 보았습니다.
<<<<<<< HEAD
.
=======

>>>>>>> 0b881819545af457c3dbe065739ffc8bb561f9ad
---

## 1. 기술 연구 및 시도 이력 (Deep Research)

카카오톡의 폐쇄적인 보안 및 독자적인 렌더링 구조를 극복하기 위해 수행한 기술적 실험 기록입니다.

### [Research 01] UI 가상화 및 접근성 차단 분석
- **시도**: Microsoft UI Automation(UIA) 및 MSAA 표준 패턴을 이용한 직접 텍스트 추출.
- **발견**: `Accessibility Insights.exe` 분석 결과, 카톡은 표준 컨트롤을 쓰지 않고 자체적으로 그림을 그리는 것으로 추측됩니다. (`IsTextPatternAvailable: False`).
- **결론**: 표준 접근성 API로는 텍스트 스트림 확보가 불가능함 (관련: `01_uia_msaa_failure_analysis.py`)

### [Research 02] 커널 메시지 주입 및 스레드 동기화 시도
- **시도**: `AttachThreadInput`으로 봇과 카톡의 입력 스레드를 결합하고 `WM_GETTEXT` 커널 신호 주입.
- **발견**: 창 제목(Caption) 획득에는 성공했으나, 내부 대화 상자는 외부 스레드의 데이터 요청을 거부하도록 설계됨 확인.
- **결론**: 시스템 표준 프로토콜을 우회하는 카톡의 강력한 보안 정책 확인. (관련: `02_kernel_api_failure_analysis.py`)

### [Research 03] 프로세스 식별 및 오탐지 해결
- **시도**: 제목이 같은 브라우저나 터미널 창을 카톡으로 오인하는 문제 해결.
- **해결**: 단순히 창 제목만 보지 않고, 핸들의 소유 프로세스명(`KakaoTalk.exe`)을 2중 검증하여 타겟팅 정확도 100% 달성. (관련: `03_process_targeting_study.py`)

### [Research 04] 송신 이벤트 트리거 실패 분석
- **시도**: `WM_SETTEXT` 및 `SendInput`(하드웨어 타이핑)을 통한 백그라운드 전송.
- **발견**: 텍스트 주입은 성공하나 카톡 내부의 '입력 감지 이벤트'가 발생하지 않아 전송 버튼이 활성화되지 않음.
- **결론**: 단순 주입이 아닌 '붙여넣기(V)'와 'Enter' 이벤트를 조합한 최종 솔루션 도출. (관련: `04_send_message_failure_analysis.py`)

### [Research 05] 시스템 권한 격리(UIPI) 대응
- **분석**: 분석 도구(Inspect)에서는 보이나 파이썬 코드 접근이 차단되는 원인이 관리자 권한 프로세스 정보를 일반 권한이 읽지 못하는 **UIPI(User Interface Privilege Isolation)** 문제임을 진단.
- **해결**: 실행 환경 승격을 통해 OS 레벨의 통신 권한 확보.

---

## 2. 핵심 엔지니어링 고민 및 해결 (Deliberations)

### ① 사용자 경험(UX) 최적화: "스텔스 컨트롤"
- **포커스 뺏기 및 타이핑 간섭**: 봇이 작동할 때 사용자의 작업이 중단되지 않도록 **유휴 시간 감지(Idle Time Detection)** 로직을 구현했습니다. 사용자가 3초 이상 입력을 멈췄을 때만 0.2초 이내로 복사 작업을 완료합니다.
- **유령 모드 (Ghost Mode)**: 창을 최소화하면 수집이 멈추는 문제를 해결하기 위해, 창을 물리적 화면 밖(-5000, -5000)으로 배치하여 사용자 시야와 마우스 동선에서 완전히 격리했습니다.
- **물리적 마우스 간섭 방지**: 마우스 커서를 직접 움직이면 사용자가 불편함을 느끼므로, `PostMessage` 기반의 **가상 클릭(Virtual Click)** 신호를 보내 마우스 튐 현상 없이 포커스를 획득합니다.
- **클립보드 데이터 보호**: 봇이 클립보드를 쓰기 직전 사용자의 기존 데이터를 백업하고, 작업 종료 후 즉시 복구하는 **매너 모드**를 구현하여 사용자의 데이터 유실을 차단했습니다.

### ② 데이터 무결성: "도배 대응 및 동기화 알고리즘"
- **ㅇㅇㅇ 도배 메시지 처리**: 카톡 시간 정보가 '분' 단위까지만 제공되어 발생하는 중복 판정 오류를 해결하기 위해, 단순 해시 체크가 아닌 **역방향 윈도우 매칭** 알고리즘을 설계하여 도배 메시지를 누락 없이 수집합니다.
- **효율적인 대량 데이터 필터링**: 수만 줄의 대화 내역 중 **DB의 마지막 5~10줄 뭉치(Anchor)**를 현재 카톡창의 끝에서부터 역방향으로 스캔하여, 시스템 부하를 최소화하며 신규 데이터만 정밀 수집합니다.
- **장애 복구**: 프로그램 강제 종료나 시스템 재시작 시, 매 수집 주기마다 DB 상태를 실시간 참조하는 **무상태(Stateless) 동기화**를 통해 꺼져있던 시간 동안의 메시지 유실을 자동 복구합니다.

### ③ 아키텍처 설계: "확장성 있는 MVC"
- 자바 개발자의 관점에서 **Controller - Service - Repository - Infrastructure** 계층을 엄격히 분리했습니다.
- **멀티스레딩**: 수신 루프를 백그라운드 스레드로 분리하여, 실시간 메시지 수집과 사용자의 실시간 CLI 채팅(송신)이 동시에 가능한 통합 환경을 구축했습니다.

---

## 3. 엔지니어로서의 의사결정 (Final Decision)

처음에는 UI Automation과 Memory 직접 접근을 시도했으나, 타겟 애플리케이션의 비표준 렌더링 방식과 보안 정책을 확인했습니다. 이에 따라 **데이터의 무결성(Integrity)** 을 100% 보장하면서도 **사용자 경험(UX)** 을 해치지 않는 **'클립보드 컨텍스트 백업/복원 알고리즘'** 을 상상력을 발휘하여 최종 구현했습니다.

---

## 4. 프로젝트 구조 (Project Structure)
```text
PyProject/
├── kakao_main.py             # [Controller] 프로그램 실행 및 CLI 통합 관리
├── kakao_receive_service.py  # [Service] 수집/동기화/파싱 비즈니스 로직
├── kakao_send_service.py     # [Service] 메시지 전송 및 포커스 롤백 로직
├── kakao_repository.py       # [Repository] SQLAlchemy 기반 DB CRUD
├── models.py                 # [Entity] 데이터 스키마 정의
├── database_config.py        # [Config] DB 연결 및 세션 설정
├── window_utils.py           # [Infra] OS 핸들 및 시스템 유틸리티
└── research/                 # [Research] 단계별 기술 실험 및 분석 리포트
```

---

## 5. 실행 방법 (Quick Start)
1. 카카오톡 채팅방더블 클릭하여 분리 실행
2. PyProject/kakao_main.py 최하단 controller = KakaoBotController("지혁") 부분을 지혁이 아닌 타겟할 채팅방이름 입력
3. 의존성 설치: `pip install pywin32 pyperclip psutil sqlalchemy`
4. 프로그램 실행: `python PyProject/kakao_main.py`
5. 수집 데이터 확인: `kakao_data.db` (SQLite)

---

## 6. 추후 필요시 고도화 및 확장 계획 (Future Work)

현재의 우회 방식을 넘어, 시스템 자원을 더욱 효율적으로 관리하고 보안 성벽을 정면 돌파하기 위한 고도화 계획입니다.

### ① 메모리 포인터 직접 추적 (Direct Memory Access)
- **계획**: 카카오톡 프로세스의 실제 RAM 영역을 스캔하여 대화 리스트가 저장되는 **메모리 주소(Pointer)와 오프셋(Offset)**을 추출하여 데이터를 직접 읽기.
- **한계점**: 프로그램 업데이트 시 메모리 주소가 변경되어 **유지보수 비용이 높으며**, 카톡이 메모리 값을 난독화(Obfuscation)할 경우 해독이 어려움.

### ② DLL Injection 및 내부 함수 후킹 (Hooking)
- **계획**: 카톡 프로세스 내부에 커스텀 DLL을 삽입하여, 메시지 수신 시 호출되는 **내부 이벤트 핸들러**를 가로챔.
- **한계점**: 카톡 자체 보안 엔진이나 백심에 의해 **'악성 행위'로 간주되어 계정 정지나 프로그램 차단 리스크**가 매우 큼.

### ③ 패킷 분석 및 암호화 프로토콜 해독 (Network Sniffing)
- **계획**: 카톡 고유의 **LOCO 프로토콜** 암호화 체계를 분석하여 네트워크 레이어에서 패킷 단위로 수집.
- **한계점**: 카톡의 **강력한 종단간 암호화(E2EE)**와 독자적 프로토콜 업데이트 시 분석이 원점으로 돌아갈 위험이 크며, HTTPS 복호화의 높은 장벽 존재.

### ④ 프로그램 예외 처리 및 안정성 강화
- **계획**: 지금은 except: pass로 대충 넘어가고 있는데, 나중에 에러가 왜 났는지 한눈에 볼 수 있게 로깅(Logging) 기능을 넣을 예정.
- **내용**: 윈도우 API나 클립보드가 가끔 렉 걸려서 뻗는 경우가 있는데, 이때 바로 죽지 않고 자동으로 재시도하는 로직을 추가하면 훨씬 튼튼해질 듯함.

### ⑤ DB 동시성 문제 해결
- **계획**: 지금은 SQLite를 쓰고 있어서 수신이랑 송신이 동시에 DB를 건드리면 충돌(Lock)이 날 수 있는데, 나중에 MySQL같은 서버형 DB로 옮긴후 사용자가 많다면 부하 분산을 위해 메시지 큐와 함께 사용하면 될듯함.

### ⑥ 데이터 지문(Hash)을 이용한 무결성 고도화
- **계획**: 현재의 내용 기반 해싱을 넘어, **[발신자 + 시간 + 본문 + 메시지 순번]** 을 조합한 정밀 해시 알고리즘 적용하여 역방향 방식으로 진행하고 있는 동기화 알고리즘을 개선.
- **이유**: 카카오톡 특유의 분 단위 시간 표기 한계를 극복하고, 수만 줄의 대화 내역 속에서도 개별 메시지의 고유성(Identity)을 완벽하게 식별하여 데이터 유실과 잘못된 중복을 원천 차단하기 위함.

### ⑦ FastAPI 공부후 도입을 통한 REST API 서버화 (현재 학부때 공부했던 파이썬지식 기반으로 간단히 만듦)
- **계획**: 현재의 CLI(터미널) 기반 수집기를 FastAPI 기반의 REST API 에이전트로 전환할 예정임.
- **이유 1** (생산성): 현재 수동으로 처리하고 있는 DB 세션 관리나 트랜잭션을 FastAPI의 의존성 주입 기능을 통해 자바의 Spring Boot처럼 자동화하여 코드의 복잡도를 줄이고 안정성을 높일 수 있음!
- **이유 2** (확장성): 수집기를 단순 스크립트가 아닌 하나의 '마이크로서비스'로 만들어, 나중에 Java(Spring Boot) 서버가 HTTP 통신으로 이 수집기에게 명령(메시지 전송, 수집 상태 조회 등)을 내릴 수 있는 구조를 만들기 위함.
- **이유 3** (편의성): Swagger UI 자동 생성을 통해 별도의 문서 작성 없이도 수집기의 기능을 웹에서 즉시 테스트하고 규격화할 수 있다는 장점이 큼.

### ⑧ FastAPI 공부후 도입을 통한 REST API 서버화 (현재 학부때 공부했던 파이썬지식 기반으로 간단히 만듦)
- **계획**: 현재의 CLI(터미널) 기반 수집기를 FastAPI 기반의 REST API 에이전트로 전환할 예정임.
- **이유 1** (생산성): 현재 수동으로 처리하고 있는 DB 세션 관리나 트랜잭션을 FastAPI의 의존성 주입 기능을 통해 자바의 Spring Boot처럼 자동화하여 코드의 복잡도를 줄이고 안정성을 높일 수 있음!
- **이유 2** (확장성): 수집기를 단순 스크립트가 아닌 하나의 '마이크로서비스'로 만들어, 나중에 Java(Spring Boot) 서버가 HTTP 통신으로 이 수집기에게 명령(메시지 전송, 수집 상태 조회 등)을 내릴 수 있는 구조를 만들기 위함.
- **이유 3** (편의성): Swagger UI 자동 생성을 통해 별도의 문서 작성 없이도 수집기의 기능을 웹에서 즉시 테스트하고 규격화할 수 있다는 장점이 큼.

### ⑨ 안드로이드 알림을 통한 내부 채팅 수집
- **계획**: 에뮬레이터를 이용하여 안드로이드 알림을 통한 내부 채팅 데이터 수집
- **내용**: 현재 클립보드 방식은 사용자에게 불편한 사용감을 포커스 뺏기가 있어서 불편함 이를 해결 가능할듯함.

---

## 7. 과제 하며 느낀 개인적인 생각:
처음에는 단순히 기능 구현만 생각했는데, 만들다 보니 윈도우 OS의 권한 문제나 클립보드 경합 같은 실질적인 운영 지뢰가 많다는 걸 알게 됐음. 위 개선 사항들은 이런 지뢰들을 완벽하게 피해서 24시간 안정적으로 돌아가는 시스템을 만들기 위한 고민들입니다.
